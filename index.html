<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Octopus Tariff Checker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- PWA bits -->
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <link rel="apple-touch-icon" href="icons/icon-192.png">

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 1rem;
      background: #f5f5f7;
      color: #111827;
    }
    main {
      max-width: 640px;
      margin: 0 auto;
    }
    h1 {
      font-size: 1.4rem;
      margin-bottom: 0.75rem;
    }
    h2 {
      font-size: 1.2rem;
      margin-top: 0;
    }
    .card {
      background: #ffffff;
      border-radius: 12px;
      padding: 1rem;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      margin-bottom: 1rem;
    }
    label {
      display: block;
      font-size: 0.85rem;
      margin-bottom: 0.25rem;
      font-weight: 600;
    }
    input, select {
      width: 100%;
      box-sizing: border-box;
      padding: 0.45rem 0.6rem;
      border-radius: 8px;
      border: 1px solid #d1d5db;
      font-size: 0.9rem;
      margin-bottom: 0.7rem;
    }
    button {
      border: none;
      border-radius: 999px;
      padding: 0.5rem 1rem;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      margin-right: 0.5rem;
      margin-top: 0.5rem;
    }
    button.primary {
      background: #1d4ed8;
      color: white;
    }
    button.secondary {
      background: #e5e7eb;
      color: #111827;
    }
    button:disabled {
      opacity: 0.6;
      cursor: default;
    }
    #output ul {
      padding-left: 1.2rem;
    }
    #output li {
      margin-bottom: 0.2rem;
    }
    #output pre {
      white-space: pre-wrap;
      font-size: 0.85rem;
      background: #f9fafb;
      padding: 0.5rem;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
    }
    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
    }
    .highlight {
      font-weight: 700;
    }
    .small {
      font-size: 0.8rem;
      color: #6b7280;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
<main>
  <h1>Octopus Tariff Checker</h1>

  <div class="card">
    <div class="grid-2">
      <div>
        <label for="apiKey">Octopus API key</label>
        <input id="apiKey" type="password" autocomplete="off" placeholder="sk_live_..." />
      </div>
      <div>
        <label for="accountNumber">Account number</label>
        <input id="accountNumber" type="text" autocomplete="off" placeholder="A-12345678" />
      </div>
    </div>

    <label for="deviceId">Mini device ID</label>
    <input id="deviceId" type="text" autocomplete="off" placeholder="98-B1-77-FF-FF-01-FF-31" />

    <button id="discoverDevice" class="secondary">Discover device IDs from account</button>
    <div id="deviceInfo" class="small"></div>

    <label for="dno">DNO region (Agile suffix)</label>
    <select id="dno">
      <option value="A">A – Eastern</option>
      <option value="B">B – East Midlands</option>
      <option value="C">C – London</option>
      <option value="D">D – Merseyside &amp; N. Wales</option>
      <option value="E">E – West Midlands</option>
      <option value="F">F – North East</option>
      <option value="G">G – North West</option>
      <option value="H">H – Southern</option>
      <option value="J">J – South Eastern</option>
      <option value="K">K – South Wales</option>
      <option value="L">L – South Western</option>
      <option value="M">M – Yorkshire</option>
      <option value="N">N – South Scotland</option>
      <option value="P">P – North Scotland</option>
    </select>

    <button id="run" class="primary">Compare today (Go vs Agile)</button>
    <button id="checkGaps" class="secondary">Check last 30 days for gaps</button>
    <div id="status" class="small"></div>
  </div>

  <div id="output" class="card"></div>

  <div class="card small">
    <strong>Notes</strong><br>
    • All prices assume Octopus Go: 8.5p/kWh between 00:30–05:30, 31.42p/kWh otherwise.<br>
    • Agile product assumed: AGILE-24-10-01.<br>
    • Standing charges are ignored. This is a personal “what if” tool; API key is stored only in this browser (localStorage).
  </div>
</main>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const AGILE_PRODUCT_CODE = 'AGILE-24-10-01';
  const GRAPHQL_URL = 'https://api.octopus.energy/v1/graphql/';
  const GO_OFFPEAK_P = 8.50;
  const GO_PEAK_P = 31.42;

  const apiKeyInput = document.getElementById('apiKey');
  const accountInput = document.getElementById('accountNumber');
  const deviceInput = document.getElementById('deviceId');
  const dnoSelect = document.getElementById('dno');
  const discoverBtn = document.getElementById('discoverDevice');
  const runBtn = document.getElementById('run');
  const checkGapsBtn = document.getElementById('checkGaps');
  const statusEl = document.getElementById('status');
  const outputEl = document.getElementById('output');
  const deviceInfoEl = document.getElementById('deviceInfo');

  const deviceMetaById = {}; // deviceId -> { mpan, serial }
  let lastDayIndex = null;   // dateKey -> [interval_start strings]

  // Load saved config
  (function loadConfig() {
    try {
      const cfg = JSON.parse(localStorage.getItem('octopusTariffConfig') || '{}');
      if (cfg.apiKey) apiKeyInput.value = cfg.apiKey;
      if (cfg.accountNumber) accountInput.value = cfg.accountNumber;
      if (cfg.deviceId) deviceInput.value = cfg.deviceId;
      if (cfg.dno) dnoSelect.value = cfg.dno;
    } catch (e) {}
  })();

  function saveConfig() {
    const cfg = {
      apiKey: apiKeyInput.value.trim(),
      accountNumber: accountInput.value.trim(),
      deviceId: deviceInput.value.trim(),
      dno: dnoSelect.value
    };
    localStorage.setItem('octopusTariffConfig', JSON.stringify(cfg));
  }

  function showStatus(msg) {
    statusEl.textContent = msg;
  }

  async function graphqlRequest(query, variables, jwtToken) {
    const res = await fetch(GRAPHQL_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(jwtToken ? { 'Authorization': 'JWT ' + jwtToken } : {})
      },
      body: JSON.stringify({ query, variables })
    });
    if (!res.ok) {
      const text = await res.text();
      throw new Error('GraphQL HTTP ' + res.status + ': ' + text);
    }
    const data = await res.json();
    if (data.errors && data.errors.length) {
      throw new Error('GraphQL error: ' + JSON.stringify(data.errors));
    }
    return data.data;
  }

  async function obtainKrakenToken(apiKey) {
    const query = `
      mutation obtainKrakenToken($input: ObtainJSONWebTokenInput!) {
        obtainKrakenToken(input: $input) {
          token
        }
      }
    `;
    const data = await graphqlRequest(query, { input: { APIKey: apiKey } }, null);
    const token = data?.obtainKrakenToken?.token;
    if (!token) throw new Error('No token returned');
    return token;
  }

  async function discoverDeviceIds(accountNumber, jwtToken) {
    const query = `
      query MyDevices($accountNumber: String!) {
        account(accountNumber: $accountNumber) {
          electricityAgreements(active: true) {
            meterPoint {
              mpan
              meters(includeInactive: false) {
                id
                serialNumber
                smartDevices {
                  deviceId
                }
              }
            }
          }
        }
      }
    `;
    const data = await graphqlRequest(query, { accountNumber }, jwtToken);
    const devices = [];
    const agreements = data?.account?.electricityAgreements || [];
    agreements.forEach(agr => {
      const mp = agr.meterPoint;
      if (!mp) return;
      const mpan = mp.mpan;
      (mp.meters || []).forEach(meter => {
        const serial = meter.serialNumber;
        (meter.smartDevices || []).forEach(sd => {
          if (sd.deviceId) {
            devices.push({ mpan, serial, deviceId: sd.deviceId });
          }
        });
      });
    });
    return devices;
  }

  function renderDeviceSelector(devices) {
    if (!devices.length) {
      deviceInfoEl.textContent = 'No smart devices found for this account.';
      return;
    }

    devices.forEach(d => {
      deviceMetaById[d.deviceId] = { mpan: d.mpan, serial: d.serial };
    });

    const select = document.createElement('select');
    select.style.marginTop = '0.4rem';
    devices.forEach(d => {
      const opt = document.createElement('option');
      opt.value = d.deviceId;
      opt.textContent = `${d.serial} (${d.mpan})`;
      select.appendChild(opt);
    });
    select.addEventListener('change', e => {
      deviceInput.value = e.target.value;
      saveConfig();
    });

    deviceInfoEl.innerHTML = 'Select device:';
    deviceInfoEl.appendChild(document.createElement('br'));
    deviceInfoEl.appendChild(select);

    if (devices.length === 1) {
      deviceInput.value = devices[0].deviceId;
      saveConfig();
    }
  }

  async function fetchMiniTelemetry(jwtToken, deviceId) {
    const now = new Date();
    const start = new Date(now);
    start.setHours(0, 0, 0, 0);
    const end = new Date(now);
    end.setHours(23, 59, 59, 0);

    const fmt = d => d.toISOString().replace('.000Z', '+00:00');
    const startStr = fmt(start);
    const endStr = fmt(end);

    const query = `
      query Telemetry($deviceId: String!, $start: DateTime!, $end: DateTime!, $grouping: TelemetryGrouping!) {
        smartMeterTelemetry(
          deviceId: $deviceId,
          start: $start,
          end: $end,
          grouping: $grouping
        ) {
          readAt
          consumptionDelta
          costDeltaWithTax
        }
      }
    `;

    const data = await graphqlRequest(
      query,
      { deviceId, start: startStr, end: endStr, grouping: 'HALF_HOURLY' },
      jwtToken
    );

    return data.smartMeterTelemetry || [];
  }

  async function fetchAgileRates(dnoLetter) {
    const base = `https://api.octopus.energy/v1/products/${AGILE_PRODUCT_CODE}/electricity-tariffs/E-1R-${AGILE_PRODUCT_CODE}-${dnoLetter}/standard-unit-rates/`;

    const today = new Date();
    const start = new Date(today);
    start.setHours(0, 0, 0, 0);
    const end = new Date(today);
    end.setHours(23, 59, 59, 0);

    const toUtcZ = d => {
      const iso = d.toISOString();
      return iso.replace('.000Z', 'Z');
    };

    const url = `${base}?${new URLSearchParams({
      period_from: toUtcZ(start),
      period_to: toUtcZ(end),
      page_size: '1500'
    }).toString()}`;

    const res = await fetch(url);
    if (!res.ok) {
      const text = await res.text();
      throw new Error('Agile HTTP ' + res.status + ': ' + text);
    }
    const json = await res.json();
    const results = json.results || [];
    const lookup = {};
    results.forEach(r => {
      if (r.valid_from && typeof r.value_inc_vat === 'number') {
        lookup[r.valid_from] = r.value_inc_vat;
      }
    });
    return lookup;
  }

  async function fetchConsumptionLast30Days(apiKey, mpan, serial) {
    const now = new Date();

    // end: day before yesterday (exclude today & yesterday)
    const end = new Date(Date.UTC(
      now.getUTCFullYear(),
      now.getUTCMonth(),
      now.getUTCDate() - 2,
      23, 59, 59, 0
    ));

    // start: 29 days before end
    const start = new Date(Date.UTC(
      end.getUTCFullYear(),
      end.getUTCMonth(),
      end.getUTCDate() - 29,
      0, 0, 0, 0
    ));

    const toUtcZ = d => d.toISOString().replace('.000Z', 'Z');

    const url = `https://api.octopus.energy/v1/electricity-meter-points/${mpan}/meters/${serial}/consumption/?` +
      new URLSearchParams({
        period_from: toUtcZ(start),
        period_to:   toUtcZ(end),
        page_size:   '5000',
        order_by:    'period'
      }).toString();

    const res = await fetch(url, {
      headers: {
        'Authorization': 'Basic ' + btoa(apiKey + ':')
      }
    });
    if (!res.ok) {
      const text = await res.text();
      throw new Error('Consumption HTTP ' + res.status + ': ' + text);
    }
    const json = await res.json();
    return { results: json.results || [], start, end };
  }

  function buildDayIndex(results) {
    const index = {};
    results.forEach(r => {
      const s = r.interval_start;
      if (!s) return;
      const dayKey = s.slice(0, 10);
      if (!index[dayKey]) index[dayKey] = [];
      index[dayKey].push(s);
    });
    return index;
  }

  function detectDayGaps(dayIndex, startDate, endDate) {
    const gaps = [];
    let d = new Date(startDate.getTime());
    while (d <= endDate) {
      const key = d.toISOString().slice(0, 10);
      const count = (dayIndex[key] || []).length;
      const expected = 48;
      if (count === 0) {
        gaps.push({ date: key, type: 'none', missing: expected, got: 0 });
      } else if (count < expected) {
        gaps.push({ date: key, type: 'partial', missing: expected - count, got: count });
      }
      d.setUTCDate(d.getUTCDate() + 1);
    }
    return gaps;
  }

  function calculateComparison(telemetryRows, agileLookup) {
    let totalActualP = 0;
    let totalGoP = 0;
    let totalAgileP = 0;
    let totalKWh = 0;

    telemetryRows.forEach(row => {
      const readAtStr = row.readAt;

      const deltaWh    = Number(row.consumptionDelta)    || 0;
      const costDeltaP = Number(row.costDeltaWithTax)    || 0;

      const kWh = deltaWh / 1000.0;

      const date = new Date(readAtStr);
      const hour = date.getHours();
      const minute = date.getMinutes();

      const isOffPeak =
        (hour > 0 && hour < 5) ||
        (hour === 0 && minute >= 30) ||
        (hour === 5 && minute === 0);

      const goRateP = isOffPeak ? GO_OFFPEAK_P : GO_PEAK_P;
      const goCostP = kWh * goRateP;

      const utcIso = date.toISOString().replace('.000Z', 'Z');
      const agileRateP = agileLookup[utcIso] || 0;
      const agileCostP = kWh * agileRateP;

      totalActualP += costDeltaP;
      totalGoP += goCostP;
      totalAgileP += agileCostP;
      totalKWh += kWh;
    });

    return {
      kWh: totalKWh,
      actualGBP: totalActualP / 100.0,
      goGBP: totalGoP / 100.0,
      agileGBP: totalAgileP / 100.0
    };
  }

  function showDayDetail(dateKey) {
    if (!lastDayIndex) return;
    const intervals = (lastDayIndex[dateKey] || []).slice().sort();
    const expected = [];
    let d = new Date(dateKey + 'T00:00:00Z');
    for (let i = 0; i < 48; i++) {
      expected.push(d.toISOString().replace('.000Z', 'Z'));
      d = new Date(d.getTime() + 30 * 60 * 1000);
    }
    const haveSet = new Set(intervals.map(s => s.replace('.000Z', 'Z')));
    const missing = expected.filter(s => !haveSet.has(s));

    const detailsText =
      `Details for ${dateKey} (UTC intervals)\n\n` +
      `Present intervals (${intervals.length}):\n` +
      (intervals.length ? intervals.join('\n') : 'None') +
      `\n\nMissing intervals (${missing.length}):\n` +
      (missing.length ? missing.join('\n') : 'None');

    const gapDetailsEl = outputEl.querySelector('#gapDetails');
    if (gapDetailsEl) {
      gapDetailsEl.textContent = detailsText;
    }
  }

  discoverBtn.addEventListener('click', async () => {
    try {
      saveConfig();
      const apiKey = apiKeyInput.value.trim();
      const accountNumber = accountInput.value.trim();
      if (!apiKey || !accountNumber) {
        alert('Please enter API key and account number first.');
        return;
      }
      discoverBtn.disabled = true;
      showStatus('Obtaining token & discovering devices...');
      const token = await obtainKrakenToken(apiKey);
      const devices = await discoverDeviceIds(accountNumber, token);
      renderDeviceSelector(devices);
      showStatus('Device discovery complete.');
    } catch (err) {
      console.error(err);
      showStatus('Error: ' + err.message);
    } finally {
      discoverBtn.disabled = false;
    }
  });

  runBtn.addEventListener('click', async () => {
    try {
      saveConfig();
      const apiKey = apiKeyInput.value.trim();
      const accountNumber = accountInput.value.trim();
      const deviceId = deviceInput.value.trim();
      const dno = dnoSelect.value;

      if (!apiKey || !accountNumber || !deviceId) {
        alert('Please enter API key, account number and device ID.');
        return;
      }

      runBtn.disabled = true;
      outputEl.innerHTML = '';
      showStatus('Getting token, usage & prices...');

      const token = await obtainKrakenToken(apiKey);
      const telemetry = await fetchMiniTelemetry(token, deviceId);
      showStatus(`Got ${telemetry.length} telemetry rows. Fetching Agile prices...`);

      const agileLookup = await fetchAgileRates(dno);
      if (!Object.keys(agileLookup).length) {
        showStatus('No Agile rates returned for today. Agile comparison will be zero.');
      }

      const { kWh, actualGBP, goGBP, agileGBP } =
        calculateComparison(telemetry, agileLookup);

      let winnerLabel = 'Your current tariff';
      const min = Math.min(actualGBP, goGBP, agileGBP);
      if (min === goGBP) {
        winnerLabel = 'Octopus Go';
      } else if (min === agileGBP) {
        winnerLabel = 'Octopus Agile';
      }

      const todayStr = new Date().toISOString().slice(0, 10);

      outputEl.innerHTML = `
        <h2>Comparison for ${todayStr}</h2>
        <p>Energy used today: <span class="highlight">${kWh.toFixed(3)} kWh</span></p>
        <ul>
          <li>Actual: £${actualGBP.toFixed(2)}</li>
          <li>Go (8.5p 00:30–05:30, 31.42p rest): £${goGBP.toFixed(2)}</li>
          <li>Agile (${AGILE_PRODUCT_CODE}, region ${dno}): £${agileGBP.toFixed(2)}</li>
        </ul>
        <p><strong>Cheapest today: ${winnerLabel}</strong></p>
        <p class="small">Standing charges ignored in all cases.</p>
      `;
      showStatus('Done.');
    } catch (err) {
      console.error(err);
      showStatus('Error: ' + err.message);
      outputEl.innerHTML = '';
    } finally {
      runBtn.disabled = false;
    }
  });

  checkGapsBtn.addEventListener('click', async () => {
    try {
      saveConfig();
      const apiKey = apiKeyInput.value.trim();
      const deviceId = deviceInput.value.trim();
      if (!apiKey || !deviceId) {
        alert('Please enter API key and device ID (and run device discovery if needed).');
        return;
      }
      const meta = deviceMetaById[deviceId];
      if (!meta) {
        showStatus('Please click "Discover device IDs from account" first so we know MPAN and meter serial.');
        return;
      }

      checkGapsBtn.disabled = true;
      outputEl.innerHTML = '';
      lastDayIndex = null;
      showStatus('Checking last 30 days (excluding today & yesterday) for gaps...');

      const { results, start, end } =
        await fetchConsumptionLast30Days(apiKey, meta.mpan, meta.serial);

      const dayIndex = buildDayIndex(results);
      lastDayIndex = dayIndex;

      const gaps = detectDayGaps(dayIndex, start, end);

      const fromStr = start.toISOString().slice(0, 10);
      const toStr   = end.toISOString().slice(0, 10);

      if (!gaps.length) {
        outputEl.innerHTML = `
          <h2>Data gaps (last 30 days)</h2>
          <p>No gaps detected between ${fromStr} and ${toStr} (all days have 48 readings).</p>
          <div id="gapDetails" class="small"></div>
        `;
      } else {
        const lines = gaps.map(g =>
          `<div>${g.date}: ${
            g.type === 'none'
              ? 'NO DATA'
              : 'Missing ' + g.missing + ' intervals (got ' + g.got + ')'
          } <button class="gap-detail" data-date="${g.date}">Details</button></div>`
        );
        outputEl.innerHTML = `
          <h2>Data gaps (last 30 days)</h2>
          <p>Checked ${fromStr} → ${toStr} (excluding today & yesterday).</p>
          <p>Found ${gaps.length} day(s) with missing data:</p>
          ${lines.join('')}
          <div id="gapDetails" class="small" style="margin-top:0.75rem;"></div>
        `;
      }
      showStatus('Gap check complete.');
    } catch (err) {
      console.error(err);
      showStatus('Error: ' + err.message);
      outputEl.innerHTML = '';
    } finally {
      checkGapsBtn.disabled = false;
    }
  });

  // Delegate clicks on "Details" buttons
  outputEl.addEventListener('click', e => {
    const btn = e.target.closest('.gap-detail');
    if (!btn) return;
    const date = btn.dataset.date;
    showDayDetail(date);
  });

  // Register SW (outside try/catch; ignore errors)
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('service-worker.js').catch(() => {});
  }
});
</script>
</body>
</html>
